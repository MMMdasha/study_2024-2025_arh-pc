---
## Front matter
title: "Отчёт по лабораторной работе №9"
subtitle: "Понятие подпрограммы.
Отладчик GDB."
author: "Малкина Дарья Александровна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение навыков написания программ с использованием подпрограмм. Знакомство
с методами отладки при помощи GDB и его основными возможностями.

# Выполнение лабораторной работы

1. Сначала создадим каталог lab09 и файл lab9-1.asm. Рассмотрим программу, вычисляющую f(x)=2x+7 с помощью подпрограммы _calcul. Добавим в файл lab9-1.asm текст программы из листинга 9.1. Создадим исполняемый файл и проверим его работу:

![Программа lab9-1 - f(x)=2x+7](image/1.1.png){#fig:001 width=70%}

После этого добавим в программу подпрограмму _subcalcul внутри _calcul, чтобы _subcalcul вычисляла g(x) = 3x-1, а после передавала значение x в _calcul, где будет вычислено f(g(x)):

![Добавление подпрограммы _subcalcul](image/1.2.png){#fig:002 width=70%}

Создадим исполняемый файл и проверим его работу:

![Программа lab9-1 - f((g)x)](image/1.3.png){#fig:003 width=70%}

## Отладка программам с помощью GDB

2. Создадим файл lab9-2.asm с программой из листинга 9.2 и соберем исполняемый файл. Добавим отладочную информацию, используя ключ -g: 

![Отладка программы lab9-2 с помощью GDB](image/2.1.png){#fig:004 width=70%}

После этого загрузим исполняемый файл в отладчик GDB и проверим работу программы командой run:

![Запуск программы lab9-2 в оболчке GDB](image/2.2.png){#fig:005 width=70%}

Далее установим точку останова на метке _start командой break _start и запустим программу еще раз:

![Установка точки останова на метке _start](image/2.3.png){#fig:006 width=70%}

Затем посмотрим дизассемблированный код командой disassemble _start:

![Дизассемблированный код программы lab9-2](image/2.4.png){#fig:007 width=70%}

Переключимся на синтаксис Intel командой set disassembly-flavor intel и снова выведем дизассемблированный код:

![Дизассемблированный код - синтаксис Intel](image/2.5.png){#fig:008 width=70%}

Заметим, что отображения кода в режимах ATT и Intel различаются:

Режим ATT - операнды пишутся в порядке источник, затем приемник, при этом перед именем регистра ставится символ %, а непосредственные значения обозначаются знаком $ перед числом. 

Режим Intel - операнды пишутся в порядке приемник, затем источник. Префикса % перед регистрами нет и нак $ не используется для обозначения непосредственных значений. 

Включим режим псевдографики командами layout asm и layout regs:

![Режим псевдографики ](image/2.6.png){#fig:009 width=70%}

### Добавление точек останова

До этого мы установили точку останова на метке _start, проверим это командой info breakpoints (i b). Затем по адресу инструкции установим еще одну точку останова командой break *<адрес>. После посмотрим информацию о всех установленных точках останова командой i b:

![Точки останова](image/2.7.png){#fig:010 width=70%}

### Работа с данными программы в GDB

Воспользуемся командой stepi (si) пять раз, и понаблюдаем, как меняются значения регистров после каждой инструкции:

![Команда stepi](image/2.8.png){#fig:011 width=70%}


Воспользуемся командой x/1sb &msg1 для просмотра значения msg1. Затем мы найдем значение msg2 по адресу (определим адресс в дизассемблированной инструкции).

![Просмотр значений msg1 и msg2](image/2.9.png){#fig:012 width=70%}

Изменим первый символ msg1 командой set {char}msg1='h', после аналогично заменим первый символ в переменной msg2:

![Изменение переменных - команда set](image/2.10.png){#fig:013 width=70%}

Выведем в различных форматах (в шестнадцатеричном формате, в двоичном формате и в символьном виде) значение регистра edx:

![Команда print](image/2.11.png){#fig:014 width=70%}

С помощью команды set изменим значение регистра ebx сначала на '2',затем на 2, и после каждого изменения выведем значение edx как строку:

![Команда print](image/2.12.png){#fig:015 width=70%}

Заметим разницу в выводе:

В первом случае set $ebx='2' - мы присвоили регистру ebx строковое значение '2', поэтому команда p/s $ebx, которая выводит значение как строку, отображает ASCII-код символа "2", который равен 50.

Во втором случае set $ebx=2 - мы присвоили регистру ebx числовое значение 2, теперь команда p/s $ebx выводит число 2, потому что интерпретирует ebx как число, а не как строку.

Выходим из GDB.

### Обработка аргументов командной строки в GDB

Скопируем файл lab8-2.asm в файл lab09-3.asm, создадим исполняемый файл: 

![Создаём файл lab9-3.as](image/3.1.png){#fig:016 width=70%}

После загрузим исполняемый файл в gdb с помощью ключа --args, передав ему аргументы:

![Загружаем файл в GDB](image/3.2.png){#fig:017 width=70%}

Установим точку останова перед _start и запустим программу:

![Точка останова перед _start](image/3.3.png){#fig:018 width=70%}

Проверим количество аргументов с помощью команды x/x $esp. Результат - число 5, так как у нас есть имя программы и четыре аргумента. Далее, исследуем содержимое стека. По адресу [esp+4] находится адрес имени программы, по адресу [esp+8] — адрес первого аргумента, по адресу [esp+12] — второго, и так далее:

![Содержимое стека](image/3.4.png){#fig:019 width=70%}

Так как в 32-битных системах, адреса памяти в виде 32-битными числами(32 бита = 4 байта), поэтому мы перемещаемся по стеку с интервалом в 4 байта вперед, чтобы добраться до начала следующего 32-битного адреса.

# Выполнение задания для самостоятельной работы

1. Преобразуем программу из лабораторной работы №8 (Задание №1 для самостоятель-
ной работы), реализовав вычисление значения функции f(x) как подпрограмму.

В сегменте .bss объявим переменную res для хранения результатов вычислений:

![Переменная res](image/4.1.png){#fig:020 width=70%}

В основной программе добавим вызов подрограммы _funcalcul (33 строка) и изменим операнды в сложении промежуточных результатов функции (35 строка):

![Основная программа](image/4.2.png){#fig:021 width=70%}

Вынесем вычисления функции за основной код, добавим сохранение результата в переменную res (54 строка):

![Подпрограмма _funcalcul](image/4.3.png){#fig:022 width=70%}

Создаём исполнительный файл и запускаем его, проверим работу программы с разными аргументами, для простоты проверки введем те же аргументы, что и при проверке программы lab8-var5:

![Программа lab9-var5](image/4.4.png){#fig:024 width=70%}

Для сравнения приведем результаты работы программы lab8-var5:

![Программа lab8-var5](image/4.5.png){#fig:025 width=70%}

2. В листинге 9.3 приведена программа вычисления выражения (3+2)∗4+5. При запуске данная программа дает результат 10, что неверно, убедимся в этом, посчитав аналитически 5*4+5=20+5=25:

![Неверный результат](image/5.1.png){#fig:026 width=70%}

С помощью отладчика GDB, проанализируем изменения значений регистров и определим ошибку.

Соберем исполняемый файл, добавив отладочную информацию, после загрузим исполняемый файл в отладчик GDB и проверим работу программы:

![Запуск программы lab9-2 в оболчке GDB](image/5.2.png){#fig:027 width=70%}

Установим точку останова на метке _start и запустим программу еще раз:

![Установка точки останова на метке _start](image/5.3.png){#fig:028 width=70%}

Затем посмотрим дизассемблированный код:

![Дизассемблированный код программы lab9-4](image/5.4.png){#fig:029 width=70%}

Включим режим псевдографики и добавим точки установа по адресу инструкции  после арифметических команд:

![Добавление точек останова](image/5.5.png){#fig:030 width=70%}

Воспользуемся командами stepi и print, и понаблюдаем, как меняются значения регистров после инструкций. После инструкции add ebx,eax, регистры принимают верные значения:

![Значения регистров после add ebx,eax](image/5.6.png){#fig:031 width=70%}

Заметим, что после команды mul ecx, значение ebx остаётся неизменным, хотя должно принимать значение 5*4=20, но меняется значение eax, хотя должно оставаться равным 2. Делаем вывод, что инструкция mul ecx умножает содержимое регистра eax на ecx, а не ebx на ecx, как задумано, результат записывается в eax:

![Первая ошибка - неправильное использование инструкции mul](image/5.7.png){#fig:032 width=70%}

С помощью команды print сравним значения регистров eax, ebx, ecx до команды mul ecx и после:

![Значения регистров](image/5.8.png){#fig:033 width=70%}

Чтобы исправить это, нужно сначала скопировать содержимое ebx в eax перед выполнением mul ecx. Однако код всё равно неверный из-за того, что после умножения 5 прибавляется к ebx, а не к результату умножения, который находится в eax. Это вторая ошибка - неправильное место для второго сложения:

![Значения регистров после add edi,ebx](image/5.9.png){#fig:034 width=70%}


Исправим код, скопируем значение ebx в eax перед выполнением mul ecx и прибавим 5 напрямую к eax, после чего сохраним результат в edi:

![Исправленный код программы lab9-4](image/5.10.png){#fig:035 width=70%}

Создим исполнительный файл и запустим его, для проверки работы программы, убедимся, что после внесения изменений программа работает корректно:

![Корекктная работа программы lab9-4](image/5.11.png){#fig:036 width=70%}

# Выводы

В ходе лабораторной работы и выполнения самостоятельного задания мы приобрели практические навыки написания ассемблерных программ с использованием подпрограмм, попрактиковались в отладке программ с помощью GDB, научились использовать GDB для пошагового выполнения кода, анализа значений регистров и памяти, что позволило нам обнаружить и исправить ошибки в программе. 

# Список литературы{.unnumbered}

::: {#refs}
:::
